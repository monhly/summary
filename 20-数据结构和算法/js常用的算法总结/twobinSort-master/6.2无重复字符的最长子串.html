<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // 给定一个字符串， 请你找出其中不含有重复字符的 最长子串 的长度。

        // 示例 1:

        //     输入: "abcabcbb"
        // 输出: 3
        // 解释: 因为无重复字符的最长子串是 "abc"，
        // 所以其长度为 3。
        // 示例 2:

        //     输入: "bbbbb"
        // 输出: 1
        // 解释: 因为无重复字符的最长子串是 "b"，
        // 所以其长度为 1。
        // 示例 3:

        //     输入: "pwwkew"
        // 输出: 3
        // 解释: 因为无重复字符的最长子串是 "wke"，
        // 所以其长度为 3。
        // 请注意， 你的答案必须是 子串 的长度， "pwke"
        // 是一个子序列， 不是子串。


        var lengthOfLongestSubstring = function (s) {
            let arr = [],
                max = 0,
                i = 0;
            for (; i < s.length; i++) {
                //首次出现的位置
                let index = arr.indexOf(s[i])
                //找到在当前位置的索引
                console.log('index', index)
                if (index !== -1) {
                    arr = arr.slice(index + 1)
                    console.log('arr', arr)
                }
                arr.push(s.charAt(i));
                max = Math.max(arr.length, max)
            }
            return max
        }



        // 优化 使用map来进行优化
        var lengthofLongestSubstring = function (s) {

            let map = new Map(),
                max = 0;
            for (let index = 0, indey = 0; indey < array.length; indey++) {
                if (map.has(s[indey])) {
                    i = Math.max(map.get(s[indey] + 1, indey))
                }
                max = Math.max(max, indey - index + 1)
                map.set(s[indey], indey)
            }
            return max


        }
        console.log(lengthOfLongestSubstring("abcabc"))
            //思路:循环传入的字符串,没有就添加到数组中,有的话就从找到的索引开始进行分割,然后就继续添加. 根据每次循环的数组的长度进行比较和判断,取最大值
            //leecode 报错输出,超出文本的限制 原因是:执行的代码里面有console,log的输出,关闭即可
    </script>
</body>

</html>