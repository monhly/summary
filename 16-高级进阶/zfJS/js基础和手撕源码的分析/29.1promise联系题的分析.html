<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
</head>

<body>
    <script>
        //练习题1:s
        // console.log('script start');

        // setTimeout(() => {
        //     console.log('北歌');
        // }, 1 * 2000);

        // Promise.resolve()
        //     .then(function () {
        //         console.log('promise1');
        //     }).then(function () {
        //         console.log('promise2');
        //     }).then(() => {
        //         console.log('promise3')
        //     }).then(() => {
        //         console.log('promise4')
        //     })

        // async function foo() {
        //     await bar()
        //     console.log('async1 end')
        // }
        // foo()

        // async function errorFunc() {
        //     try {
        //         await Promise.reject('error!!!')
        //     } catch (e) {
        //         console.log(e)
        //     }
        //     console.log('async1');
        //     return Promise.resolve('async1 success')
        // }
        // errorFunc().then(res => console.log(res)).then(res => console.log('哈哈'))

        // function bar() {
        //     console.log('async2 end')
        // }

        // console.log('script end');

        // setTimeout(function () {
        //     console.log(1);
        // }, 1000);
        // console.log(2);

        new Promise((resolve) => {
                // console.log(3);
                resolve();
                // console.log(4);
            })
            .then(() => {
                console.log(5);
            })
            .then(() => {
                console.log(6);
            })
            .then(() => {
                console.log(13);
            });
        // console.log(7);
        const fn = () => {
            console.log(9);
        };
        (async function() {
            console.log(8);
            await fn();
            console.log(10);
            await fn();
            console.log(11);
            await fn();
            console.log(14);
        })();
        // console.log(12);

        // async function async1() {
        //     console.log('async 1 statt')
        //     await async2()
        //     console.log('async1 end')
        //     await console.log('async 1.1')
        //     console.log('awsync 2.2')
        // };

        // function async2() {
        //     console.log('async2')

        // };
        // console.log('script start')
        // setTimeout(() => {
        //     console.log('定时')
        // });
        // async1()

        // console.log('script end')

        // let p1 = new Promise(resolve => {
        //     console.log('1')
        //     resolve()
        // }).then(() => {
        //     console.log('2')

        // }).then(() => {
        //     console.log('3')
        // })
        // let p2 = new Promise(resolve => {
        //     // console.log('promise4')
        //     console.log('4')
        //     resolve()
        // }).then(res => {
        //     // console.log('promise5')
        //     console.log('5')
        // }).then(() => {
        //     // console.log('promise6')
        //     console.log('6')

        // })

        /*
                      链式调用中的then,返回的都是一个新的Promise,then中的回调方法都属于一个微任务
                      此时两个promise在执行的时候,会先执行传入的executor函数,所以会先输出1和4
                      然后将两个promise中的then后面的函数推入到微任务中
                      microtask queue[2的then , 5的then] ,接下来执行这两个微任务 然后将[3的then,6的tthen]推入到微任务中,
                      然后执行这两个微任务
                 */
    </script>
</body>

</html>