/*
 * JS高阶编程技巧「本质：基于“闭包”的机制完成的」 
 *   闭包的特点：
 *     + 保护
 *     + 保存
 *     + 弊端:占用内存，消耗浏览器的性能（闭包可以用，但是不能滥用）
 * 
 * 应用1：循环事件绑定或者循环操作中对于闭包的应用
 */
/* // setTimeout([function],[interval])：设置一个定时器，等待[interval]这么长的时间后，触发[function]执行
for (var i = 0; i < 3; i++) {
    setTimeout(() => {
        console.log(i);
    }, (i + 1) * 1000);
} */

/* for (var i = 0; i < 3; i++) {
    // 每一轮循环，自执行函数执行，都会产生一个私有上下文；并且是把当前这一轮循环，全局变量i的值作为实参，传递给私有上下文中的形参i
    //   + EC(AN1)  形参赋值:i=0
    //   + EC(AN2)  形参赋值:i=1
    //   + EC(AN3)  形参赋值:i=2
    // -> 每一个形成的私有上下文中，都会创建一个“箭头函数堆”，并且把其赋值给 window.setTimeout ，这样等价于，当前上下文中的某些内容，被上下文以外的东西给占用了，形成的上下文不会释放（私有变量i的值也不会被释放） 「闭包」
    (function (i) {
        setTimeout(() => {
            console.log(i);
        }, (i + 1) * 1000);
    })(i);
} */

/* // let xxx=proxy(0) -> proxy执行会产生闭包，闭包中私有的形参变量存储传递的实参信息
const proxy = i => {
    return () => {
        console.log(i);
    };
};
for (var i = 0; i < 3; i++) {
    setTimeout(proxy(i), (i + 1) * 1000);
    // 到达时间后，执行的是proxy返回的小函数
} */

// 基于let的循环（let存在“块级作用域”的处理机制）
//    + 首先浏览器会创建一个父级私有的上下文，控制循环
//    + 每一轮循环还会产生一个私有的块级上下文，都有自己的私有变量i，存储当前这一轮循环i的值
//      + EC(BLOCK1)  私有变量i=0
//      + EC(BLOCK2)  私有变量i=1
//      + EC(BLOCK3)  私有变量i=2
//    -> 每一个私有块级上下文中，也是创建一个箭头函数，并且被window.setTimeout占用了，也一样不会释放这个块级上下文「闭包」
// 和我们自己写代码形成“闭包”的区别：它是浏览器底层实现的，从性能上比我们自己写的要快那么一些
/* for (let i = 0; i < 3; i++) {
    setTimeout(() => {
        console.log(i);
    }, (i + 1) * 1000);
} */

/* 
for (let i = 0; i < 3; i++) {
    // 每一轮循环都会产生一个私有的块级上下文，如果上下文中没有什么东西被外部占用，则本轮循环结束，私有块级上下文也会被释放掉；但是一旦有东西被占用，则会产生闭包，性能上会有所消耗...
    setTimeout(() => {
        // ... 处理很多事情，但是函数中不需要使用i的值
    }, (i + 1) * 1000);
} 
*/

/* 
// 这种写法，在循环的时候就不会产生块级上下文了，性能上比之前要还好一些
let i = 0;
for (; i < 3; i++) {
    setTimeout(() => {
        // ...
    }, (i + 1) * 1000);
} 
*/


/*
------i是全局下的变量

i=0 第一轮循环
    setTimeout(() => {  //设置定时器的时候，这个函数是创建不是执行
        console.log(i);
    }, 1000);
i=1 第二轮循环
    setTimeout(() => {
        console.log(i);
    }, 2000);
i=2 第三轮循环
    setTimeout(() => {
        console.log(i);
    }, 3000);
i=3 循环结束  

------1000ms时间到了
执行 () => {console.log(i);} 这个函数
    + 在形成的私有上下文中遇到变量i，发现并不是自己私有的，找上级上下文（全局）下的i
    + 结果都是循环结束后的3
*/